#include <includes.hpp>
#include <core/async.hpp>
#include <core/updater.hpp>
#include <tools/gsc_vm.hpp>
#include <tools/gsc.hpp>
#include <tools/gsc_opcodes.hpp>
#include <tools/gsc_acts_debug.hpp>

namespace {
    // Debug data generated by the acts compiler

    using namespace tool::gsc;
    using namespace tool::gsc::opcode;
    using namespace shared::gsc::acts_debug;

    void DbgLoad(T8GSCOBJContext& ctx, core::bytebuffer::ByteBuffer& dbgReader, std::ostream& asmout) {
        using namespace shared::gsc::acts_debug;
        // acts compiled file, read data
        GSC_ACTS_DEBUG* dbg = dbgReader.Ptr<GSC_ACTS_DEBUG>();
        LOG_TRACE("Reading ACTS debug data v{:x}", (int)dbg->version);
        asmout << "// ACTS compiled file, file version 0x" << std::hex << (int)dbg->version << ", acts version ";

        asmout << core::updater::GetVersionName((uint32_t)dbg->actsVersion);

        if (core::actsinfo::VERSION_ID != core::actsinfo::DEV_VERSION_ID && dbg->actsVersion == core::actsinfo::VERSION_ID) {
            asmout << "/current";
        }

        asmout << " (0x" << std::hex << core::actsinfo::VERSION_ID << ")";

        asmout << "\n";

        if (dbg->HasFeature(ADF_FLAGS)) {
            asmout << "// flags ....";
            if (!dbg->flags) asmout << " NONE";
            else {
                // read known flags

                if (dbg->HasFlag(ADFG_OBFUSCATED)) asmout << " OBFUSCATED";
                if (dbg->HasFlag(ADFG_DEBUG)) asmout << " DEBUG";
                if (dbg->HasFlag(ADFG_CLIENT)) asmout << " CLIENT";

                uint32_t pltFlag = (dbg->flags & ADFG_PLATFORM_MASK) >> ADFG_PLATFORM_SHIFT;
                if (pltFlag) {
                    Platform nplt{ (Platform)pltFlag };
                    asmout << " PLT(" << utils::MapString(utils::CloneString(PlatformName(nplt)), [](char c) { return std::isspace(c) ? '_' : std::toupper(c); }) << ")";

                    // the script is saying which platform is was compiled, so we follow it
                    if (!ctx.opt.m_ignoreDebugPlatform && pltFlag < Platform::PLATFORM_COUNT) {
                        LOG_TRACE("Using debug platform {}", PlatformName(nplt));
                        ctx.currentPlatform = nplt;
                    }
                }
            }

            asmout << "\n";
        }

        if (dbg->HasFeature(ADF_CHECKSUM)) {
            asmout << "// dbg crc .. " << "0x" << std::hex << dbg->checksum << "\n";
            if (ctx.scriptfile->GetChecksum() && ctx.scriptfile->GetChecksum() != dbg->checksum) {
                LOG_WARNING("Can't use dbg data: unmatching checksums: 0x{:x} != 0x{:x}", ctx.scriptfile->GetChecksum(), dbg->checksum);
                return;
            }
        }

        if (dbg->HasFeature(ADF_CRC_LOC)) {
            if (dbg->crc_offset) {
                asmout << "// crc loc .. " << "0x" << std::hex << dbg->crc_offset << " ";

                if (ctx.scriptfile->HasFlag(GOHF_NOTIFY_CRC_STRING)) {
                    if (dbg->crc_offset > ctx.scriptfile->GetFileSize()) {
                        asmout << "INVALID LOC";
                    }
                    else {
                        utils::PrintFormattedString(asmout << "\"", ctx.scriptfile->Ptr<const char>(dbg->crc_offset)) << "\"";
                    }
                }
                else if (ctx.scriptfile->HasFlag(GOHF_NOTIFY_CRC)) {
                    asmout << ctx.GetFLocName(dbg->crc_offset);
                }
                else {
                    asmout << "USELESS"; // why?
                }

                asmout << "\n";
            }
        }
        if (dbg->HasFeature(ADF_STRING)) {
            uint32_t* strOffsets = dbgReader.Ptr<uint32_t>(dbg->strings_offset);
            if (dbg->strings_count * sizeof(*strOffsets) > ctx.dbgSize) {
                LOG_ERROR("Bad ACTS debug strings, too far");
            }
            else {
                asmout << "// hashes ... " << std::dec << dbg->strings_count << " (offset: 0x" << std::hex << dbg->strings_offset << ")\n";
                for (size_t i = 0; i < dbg->strings_count; i++) {
                    uint32_t off = strOffsets[i];
                    if (off >= ctx.dbgSize) {
                        LOG_ERROR("Bad ACTS debug string, too far");
                        break;
                    }
                    const char* str = dbgReader.Ptr<const char>(off);

                    uint64_t hashField{ ctx.m_vmInfo->HashField(str) };
                    uint64_t hashFilePath{ ctx.m_vmInfo->HashFilePath(str) };
                    uint64_t hashPath{ ctx.m_vmInfo->HashPath(str) };
                    {
                        core::async::opt_lock_guard hlg{ hashutils::GetMutex(false) };
                        hashutils::AddPrecomputed(hashField, str, true);
                        hashutils::AddPrecomputed(hashFilePath, str, true);
                        hashutils::AddPrecomputed(hashPath, str, true);

                        if (ctx.opt.m_header) {
                            utils::PrintFormattedString(asmout << "// - #\"", str)
                                << "\" (0x" << std::hex << hashField << "/0x" << hashFilePath << "/0x" << hashPath;
                        }
                        // use all the known hashes for this VM
                        for (auto& [k, func] : ctx.m_vmInfo->hashesFunc) {
                            try {
                                int64_t hash = func.hashFunc(str);

                                if (hash) {
                                    if (ctx.opt.m_header) {
                                        asmout << "/" << k << '=' << std::hex << hash;
                                    }
                                    hashutils::AddPrecomputed(hash, str, true);
                                }
                            }
                            catch (std::exception&) {
                                // ignore
                            }
                        }
                    }
                    if (ctx.opt.m_header) {
                        asmout << ")\n";
                    }
                }
                LOG_TRACE("{} hash(es) added", dbg->strings_count);
            }
        }

        if (dbg->HasFeature(ADF_DETOUR)) {
            const GSC_ACTS_DETOUR* detours = dbgReader.Ptr<GSC_ACTS_DETOUR>(dbg->detour_offset);

            if (dbg->detour_count * sizeof(*detours) > ctx.dbgSize) {
                LOG_ERROR("Bad ACTS debug detour, too far");
            }
            else {
                for (size_t i = 0; i < dbg->detour_count; i++) {
                    const GSC_ACTS_DETOUR& detour = detours[i];

                    GscDetourInfo& det = ctx.m_gsicInfo.detours[detour.location];
                    det.name = detour.name;
                    det.fixupOffset = detour.location;
                    det.fixupSize = detour.size;
                    det.replaceFunction = detour.name;
                    det.replaceNamespace = detour.name_space;
                    det.replaceScript = detour.script;
                }
            }
        }
        if (dbg->HasFeature(ADF_DEVBLOCK_BEGIN)) {
            // not used by acts decompiler, but can be useful for a vm
            if (ctx.opt.m_header) {
                uint32_t* dvOffsets = dbgReader.Ptr<uint32_t>(dbg->devblock_offset);

                if (dbg->devblock_count * sizeof(*dvOffsets) > ctx.dbgSize) {
                    LOG_ERROR("Bad ACTS debug dev blocks, too far");
                }
                else {
                    asmout << "// devblock . " << std::dec << dbg->devblock_count << " (offset: 0x" << std::hex << dbg->devblock_offset << ")\n";
                    for (size_t i = 0; i < dbg->devblock_count; i++) {
                        uint32_t off = dvOffsets[i];
                        asmout << "// - " << ctx.GetFLocName(off) << "\n";
                    }
                }
            }
        }
        if (dbg->HasFeature(ADF_LAZYLINK)) {
            // not used by acts decompiler, but can be useful for a vm
            if (ctx.opt.m_header) {
                asmout << "// lazylink . " << std::dec << dbg->lazylink_count << " (offset: 0x" << std::hex << dbg->lazylink_offset << ")\n";

                size_t off = dbg->lazylink_offset;
                for (size_t i = 0; i < dbg->lazylink_count; i++) {
                    if (off + sizeof(GSC_ACTS_LAZYLINK) > ctx.dbgSize) {
                        LOG_ERROR("Bad ACTS debug lazylink, too far");
                        break;
                    }
                    GSC_ACTS_LAZYLINK* lzOff = dbgReader.Ptr<GSC_ACTS_LAZYLINK>(off);

                    if (off + sizeof(GSC_ACTS_LAZYLINK) + sizeof(uint32_t) * lzOff->num_address > ctx.dbgSize) {
                        LOG_ERROR("Bad ACTS debug lazylink, too far with {} addresses", lzOff->num_address);
                        break;
                    }
                    asmout << "// "
                        << hashutils::ExtractTmp("namespace", lzOff->name_space)
                        << "<" << hashutils::ExtractTmpScript(lzOff->script) << ">::"
                        << hashutils::ExtractTmp("function", lzOff->name) << "\n"
                        << "// locs: ";
                    off += sizeof(*lzOff);
                    uint32_t* locs = dbgReader.Ptr<uint32_t>(off);
                    for (size_t i = 0; i < lzOff->num_address; i++) {
                        if (i) asmout << ", ";
                        asmout << ctx.GetFLocName(locs[i]);
                    }
                    asmout << "\n";
                    off += sizeof(uint32_t) * lzOff->num_address;
                }
            }
        }
        if (dbg->HasFeature(ADF_FILES)) {
            if (ctx.opt.m_header) {
                asmout << "// files .... " << std::dec << dbg->files_count << " (offset: 0x" << std::hex << dbg->files_offset << ")\n";
                GSC_ACTS_FILES* linesOff = dbgReader.Ptr<GSC_ACTS_FILES>(dbg->files_offset);
                if (dbg->files_offset + sizeof(GSC_ACTS_FILES) * dbg->files_count > ctx.dbgSize) {
                    LOG_ERROR("Bad ACTS debug files, too far with {} lines", dbg->files_count);
                }
                else {
                    for (size_t i = 0; i < dbg->files_count; i++) {
                        GSC_ACTS_FILES& l = linesOff[i];
                        if (l.filename >= ctx.dbgSize) {
                            LOG_ERROR("Bad ACTS debug files name, too far with {}", l.filename);
                        }
                        asmout << "// - " << std::dec << dbgReader.Ptr<const char>(l.filename) << " " << l.lineStart << "->" << l.lineEnd << "\n";
                    }
                }

            }
        }
        if (dbg->HasFeature(ADF_LINES)) {
            // not used by acts decompiler, but can be useful for a vm
            if (ctx.opt.m_header) {
                asmout << "// lines .... " << std::dec << dbg->lines_count << " (offset: 0x" << std::hex << dbg->lines_offset << ")\n";
                GSC_ACTS_LINES* linesOff = dbgReader.Ptr<GSC_ACTS_LINES>(dbg->lines_offset);
                if (dbg->lines_offset + sizeof(GSC_ACTS_LINES) * dbg->lines_count > ctx.dbgSize) {
                    LOG_ERROR("Bad ACTS debug lines, too far with {} lines", dbg->lines_count);
                }
                else {
                    for (size_t i = 0; i < dbg->lines_count; i++) {
                        GSC_ACTS_LINES& l = linesOff[i];
                        asmout << "// - " << std::dec << l.lineNum << " " << ctx.GetFLocName(l.start) << "->" << ctx.GetFLocName(l.end) << "\n";
                    }
                }

            }
        }
    }

    REGISTER_GDB_HANDLE(MAGIC, DbgLoad);
}